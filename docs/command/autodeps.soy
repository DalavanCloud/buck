{namespace buck.autodeps}

/***/
{template .soyweb}
  {call buck.page}
    {param title: 'buck autodeps' /}
    {param prettify: true /}
    {param description}

    {/param}
    {param content}

{call buck.command}

{param overview}
<h1 class="warning">THIS COMMAND IS HIGHLY EXPERIMENTAL AND IS SUBJECT TO CHANGE WITHOUT NOTICE!</h1>

<blockquote>
Normally, we would not publicly document a feature of Buck that is in such early stages; however,
because we are using it in Buck itself, contributors need to know how it works.
</blockquote>

<h2>tl;dr</h2>

We have an experimental feature to auto-generate the <code>deps</code> for
<code>java_library()</code> rules.

<h2>The Problem</h2>

<p>
Maintaining your <code>deps</code> by hand in a <code>BUCK</code> file can be tedious.
In practice, most programming languages have an existing mechanism for expressing dependencies
in the source code, so what appears in your <code>deps</code> often duplicates that information.
For example, in Java, there is often a straightforward mapping between
your <code>import</code> statements and your <code>deps</code>.

<p>
To make matters worse, the tools that you use to write in your programming language often help
keep the dependencies in your code up to date, but do not help with your <code>BUCK</code> files.
Let's consider Java, which has many great IDEs that support all sorts of far-reaching
refactoring operations. Although the IDE may make it simple to do something like extract an
interface for a class, it will not help you split the new interface into its
own <code>java_library()</code> rule in Buck and update all of your <code>deps</code>, as appropriate.

<p>
This is bad. Particularly because developers frequently work around this in one of two ways:
<ul>
  <li>They let small modules grow into large ones out of concern that the cost of having to
      update so many <code>BUCK</code> files outweights the benefit of having smaller modules.
  <li>They split up the <code>srcs</code> of a large library, but copy-paste
      the <code>deps</code>. The result is that the resulting libraries end up with
      superfluous items in the <code>deps</code>, which can slow down build times.
</ul>

Developers should not have to choose between using the full power of their IDE and
fast build times.

<h2>Our Experimental Solution</h2>

<p>
The idea is that you can opt-in to letting Buck auto-generate the <code>deps</code> of
individual <code>java_library()</code> and <code>java_test()</code> rules by adding
the argument <code>autodeps = True</code> to the rule. In practice, a rule
with <code>autodeps = True</code> should almost always have an empty argument
for <code>deps</code>. (Ideally, we would print a warning when this is not the case.)

<p>
After you have added <code>autodeps = True</code> and you have deleted your <code>deps</code>,
the next step is to run <code>buck autodeps</code>. For every <code>BUCK</code> file
with an <code>autodeps = True</code>, a <code>BUCK.autodeps</code> file should be
generated alongside of it. The <code>BUCK.autodeps</code> file contains the list of
autogenerated dependencies, as well as a SHA-1 signature of its contents.
(Signature checking is currently disabled, but we plan to turn it on by default once we
believe <code>buck autodeps</code> is reliable.)

<p>
Now when Buck parses a <code>BUCK</code> file, it looks alongside it for the presence
of a <code>BUCK.autodeps</code> file. If present, it uses it to amend the <code>deps</code> of
the rules declared therein. <strong>As things work today</strong>, we recommend checking
in your <code>BUCK.autodeps</code> files. Admittedly, checking in generated code is gross,
causes merge conflicts, etc. However, until we are sure that <code>buck autodeps</code> is
performant, checking in the files ensures that someone who checks out the code can build right
away without waiting for <code>buck autodeps</code> to run. Also, in the early stages
of <code>buck autodeps</code>, it makes it easier to identify when <code>buck autodeps</code> has
decided to change what it generates. (Such changes should be sanity-checked against changes
in the <code>.java</code> code that accompany the changes to <code>BUCK.autodeps</code> files.)

<p>
As you can see from the <a href="#troubleshooting">Troubleshooting</a> section,
there are many ways that <code>buck autodeps</code> can end up doing the wrong thing.
The hope is that we provide enough configuration options that you can always get it
to do the right thing if you put the effort in.

<h2>How Autodeps Are Chosen</h2>

<p>
The process of auto-generating dependencies is pretty straightforward. First, Buck looks
at all of the <code>srcs</code> across all of
the <code>java_library()</code> and <code>java_test()</code> rules in your project
and parses (but does not compile!) them to see which types they provide and require.
For each required symbol for a rule with <code>autodeps = True</code>, it is resolved
as follows:

<ul>
  <li>If there is a prefix match in <code>.buckconfig</code> under
      the <code>java-package-mappings</code> option
      in the <code>[autodeps]</code> section, the corresponding build target is
      added to the <code>deps</code>.
  <li>If there is exactly one visible provider of the symbol, its build target is
      added to the <code>deps</code>.
  <li>If there are multiple visible providers, then a warning is printed.
      The developer is responsible for deciding how to resolve the warning.
      (Often, this is done by restricting the visibility of all but one provider.)
  <li>If there are zero [visible] providers, then a check is done for providers
      that appear in the <code>exported_deps</code> of other visible rules.
  <ul>
    <li>If there is exactly one, its build target is added to the <code>deps</code>.
    <li>If there is more than one, a warning is printed.
    <li>If there are zero, nothing is printed and Buck assumes that the user will
        take action if/when compilation fails, as a result. It's possible that this
        is an edge case where the user has to hardcode something in the
        rule's <code>deps</code>.
</ul>

<p>
Buck only looks at non-generated <code>srcs</code> for the rule and parses (but does
not compile) the <code>.java</code> files. In the absence of compilation, some
expressions are ambiguous. Buck assumes that you are following traditional Java naming
conventions when deciding how to resolve an ambiguity. For example, if you have
the following code:

<p>
{literal}<pre class="prettyprint lang-java">
Object obj = com.foo.Bar.baz();
</pre>{/literal}

<p>
Buck assumes that this is a fully qualified reference to the class <code>com.foo.Bar</code> with
a static method named <code>baz()</code>. It is also possible for this to refer to a
class whose fully-qualified name is <code>com.foo</code> with a field named <code>Bar</code> with
a static method named <code>baz()</code>. However, the latter would violate standard Java
naming conventions because <code>foo</code> should start with an uppercase letter if it
identifies a class, so Buck will assume the former, instead.
As a result, Buck adds <code>com.foo.Bar</code> to the set of required symbols for the
build rule that contains this Java code.

<h2 id="troubleshooting">Troubleshooting</h2>

When <code>buck autodeps</code> does not generate the correct <code>deps</code>,
there are several things you can do to fix it, depending on the problem.
First you must determine whether the dependencies
are <em>underspecified</em> or <em>overspecified</em>.
You can find examples of all of the remediation strategies below (except the
one bad one that we call out) in Buck's own use of <code>buck autodeps</code>.

<h3>Fixing Underspecified Deps</h3>

<p>
There are several ways to solve this problem.

<p>
The quickest and dirtiest solution is to add the missing build target manually to
the <code>deps</code> argument of your build rule. This is the least desirable solution
because if your library evolves to the point where it no longer needs that
dependency, you will probably never discover the change and you will be
over-depping, slowing down your build times. This may be a reasonable thing to do
locally while you are developing, but you should clean this up before you commit
your change. (At least add a <code>TODO</code> or a <code>FIXME</code> so you have
some chance of coming back to the problem in the future and fixing it.)

<p>
Note that we managed to add support for <code>autodeps = True</code> to
all of the <code>java_library()</code> rules under the <code>src/</code> directory
in Buck without resorting to adding hardcoded <code>deps</code>. (Instead, we used the
remediation strategies discussed below.) There were several cases where we
decided to use the default of <code>autodeps = False</code> where we had sensitive
code where it would have been an error for it to take on any dependencies.
We would generally include a comment inside the empty <code>deps</code> array with
a reason explaining why we do not want to auto-generate dependencies for that rule.
(We don't load classes via reflection in Buck, but if we did, that would also be
a legitimate case for manually adding something to your deps.)

<p>
The most common problem is that the Java code in your library has an implicit reference
to a type for which it does not have an <code>import</code> statement, but is required to be
on the classpath in order to compile your code. There are multiple possible causes for this:

<ul>
  <li>You have a chained expression, and one of the intermediate results of the expression
      is a type that <code>javac</code> needs to compile your code, but for which you are
      not required to declare an <code>import</code> statement. In this case, the easiest
      fix is often the manuever employed by (LINK TO COMMIT ON GITHUB HERE)
      where you break up your chained expression and create a local variable with the
      implicit type, thereby forcing the presence of an <code>import</code> statement.
      Make sure to re-run <code>buck autodeps</code> once you have done this.
      Verify that the missing dependency now appears in your <code>BUCK.autodeps</code> file.
  <li>You are extending a type or interface and there are types in the supertype that
      do not appear in your <code>deps</code>. In this case, the right thing to do is update
      the <code>java_library</code> rule for the supertype and include the types it uses
      in its signatures in its <code>exported_deps</code>. This also applies to annotations
      that are declared on the supertype, as well. If they are from a different rule, then they
      should also be exported.
  <li>You are referencing a type that is generated by a <code>java_library()</code>'s
      annotation processor. Honestly, this is the worst, and our existing solution is not
      great. (We mentioned this is an experimental feature, right?) Currently, you have to
      add an explicit mapping from the fully-qualified name of the type that will be generated
      by the annotation processor and map it to the build target that is responsible for
      generating it in your <code>.buckconfig</code> file.
  <li>You are referencing a type provided by a <code>prebuilt_jar</code> or some other rule.
      In this case, the solution is the same as the above where you have to add an explicit
      entry in your <code>.buckconfig</code>. Ultimately, we plan to automate this
      for <code>prebuilt_jar</code> rules when the <code>binary_jar</code> points to a file
      that is not generated, but we have not implemented that yet. Also, we only want to
      provide such a feature if we're sure that it can be fast (which should be possible if
      we leverage Buck's cache).
</ul>

<h3>Fixing Overspecified Deps</h3>

<p>
If <code>buck autodeps</code> introduces dependencies that you did not want, then you have
two options:

<ul>
  <li>Modify the visibility of the unwanted rule such that it is not visible to the rule
      that is ending up with it in its <code>deps</code>. The <code>buck autodeps</code> command
      will not include rules that it knows are not visible to the target rule.
      (The one exception is when there is an explicit mapping in your <code>.buckconfig</code> file.
      Buck does not check the visibility when applying such mappings.)
  <li>Add the build target of the unwanted dependency to the <code>provided_deps</code> of
      your rule that is ending up with the unwanted dependency.
</ul>

{/param} // overview
{/call} // buck.command

    {/param}  // content
  {/call} // buck.page
{/template}
